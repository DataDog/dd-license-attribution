# SPDX-License-Identifier: Apache-2.0
#
# Unless explicitly stated otherwise all files in this repository are licensed under the Apache License Version 2.0.
#
# This product includes software developed at Datadog (https://www.datadoghq.com/).
# Copyright 2026-present Datadog, Inc.

# Command for cleaning SPDX license identifiers in CSV files using LLMs

import logging
import os
import sys
from pathlib import Path
from typing import Annotated, Any

import typer

from dd_license_attribution.adaptors.os import write_file
from dd_license_attribution.license_cleaner.llm_client import create_llm_client
from dd_license_attribution.license_cleaner.spdx_cleaner import SPDXCleaner
from dd_license_attribution.metadata_collector.strategies.license_3rdparty_metadata_collection_strategy import (  # noqa: E501
    License3rdPartyMetadataCollectionStrategy,
)
from dd_license_attribution.report_generator.writters.csv_reporting_writter import (
    CSVReportingWritter,
)
from dd_license_attribution.utils.logging import setup_logging

logger = logging.getLogger("dd_license_attribution")


def clean_spdx_id(
    input_csv: Annotated[
        str,
        typer.Argument(
            help="Path to the input CSV file containing license information to clean."
        ),
    ],
    output_csv: Annotated[
        str,
        typer.Argument(help="Path where the cleaned CSV file will be written."),
    ],
    llm_provider: Annotated[
        str,
        typer.Option(
            "--llm-provider",
            help="LLM provider to use for license identification (openai or anthropic).",
            rich_help_panel="LLM Configuration",
        ),
    ] = "openai",
    api_key: Annotated[
        str | None,
        typer.Option(
            "--api-key",
            help="API key for the LLM provider. Can also be set via environment variable (OPENAI_API_KEY or ANTHROPIC_API_KEY).",
            rich_help_panel="LLM Configuration",
        ),
    ] = None,
    model: Annotated[
        str | None,
        typer.Option(
            "--model",
            help="Specific model to use (e.g., 'gpt-4', 'claude-3-5-sonnet-20241022'). Uses provider default if not specified.",
            rich_help_panel="LLM Configuration",
        ),
    ] = None,
    silent: Annotated[
        bool,
        typer.Option(
            "--silent",
            help="Run in silent mode without asking for user confirmation of changes.",
            rich_help_panel="Execution Options",
        ),
    ] = False,
    log_level: Annotated[
        str,
        typer.Option(
            "--log-level",
            help="Set the logging level. Default is INFO.",
            rich_help_panel="Logging Options",
        ),
    ] = "INFO",
) -> None:
    """
    Clean SPDX license identifiers in a CSV file by converting long license
    descriptions to valid SPDX identifiers using LLMs.

    This command reads a CSV file (typically generated by generate-sbom-csv),
    identifies licenses that are long text descriptions instead of SPDX
    identifiers, and uses an LLM to convert them to proper SPDX identifiers.

    Example usage:

        # Using OpenAI (default)
        dd-license-attribution clean-spdx-id input.csv output.csv --api-key YOUR_KEY

        # Using Anthropic Claude
        dd-license-attribution clean-spdx-id input.csv output.csv \\
            --llm-provider anthropic --api-key YOUR_KEY

        # Silent mode (no confirmation prompts)
        dd-license-attribution clean-spdx-id input.csv output.csv \\
            --api-key YOUR_KEY --silent
    """
    # Setup logging
    log_level_map = {
        "DEBUG": logging.DEBUG,
        "INFO": logging.INFO,
        "WARNING": logging.WARNING,
        "ERROR": logging.ERROR,
    }

    if log_level.upper() not in log_level_map:
        logger.error(
            "Invalid log level: %s. Must be one of: DEBUG, INFO, WARNING, ERROR",
            log_level,
        )
        sys.exit(1)

    setup_logging(log_level_map[log_level.upper()])

    # If API key not provided via command line, check environment variable based on provider
    if not api_key:
        env_var_name = (
            "OPENAI_API_KEY"
            if llm_provider.lower() == "openai"
            else "ANTHROPIC_API_KEY"
        )
        api_key = os.environ.get(env_var_name)

    # Validate API key
    if not api_key:
        logger.error(
            "API key is required. Provide it via --api-key option or set %s environment variable.",
            (
                "OPENAI_API_KEY"
                if llm_provider.lower() == "openai"
                else "ANTHROPIC_API_KEY"
            ),
        )
        sys.exit(1)

    # Validate input file exists
    input_path = Path(input_csv)
    if not input_path.exists():
        logger.error("Input CSV file not found: %s", input_csv)
        sys.exit(1)

    # Validate output path is writable
    output_path = Path(output_csv)
    if output_path.exists() and not silent:
        overwrite = typer.confirm(
            f"Output file {output_csv} already exists. Overwrite?", err=True
        )
        if not overwrite:
            logger.info("Operation cancelled by user")
            sys.exit(0)

    try:
        # Create LLM client
        logger.info("Initializing %s LLM client", llm_provider)
        llm_client = create_llm_client(llm_provider, api_key, model)

        # Read and parse input CSV to metadata using existing strategy
        logger.info("Reading input CSV from: %s", input_csv)
        strategy = License3rdPartyMetadataCollectionStrategy(str(input_path.absolute()))
        metadata_list = strategy.augment_metadata([])

        # Define callback for interactive prompting (if not in silent mode)
        def prompt_for_change(change_info: dict[str, Any]) -> bool:
            """Prompt user to confirm each individual change."""
            logger.info(
                "\n--- Proposed Change ---\nComponent: %s\nOrigin: %s\nOriginal: %s\nConverted to: %s",
                change_info["component"],
                change_info["origin"],
                change_info["original"],
                change_info["converted"],
            )
            return typer.confirm("Apply this change?", err=True, default=True)

        # Clean the metadata
        cleaner = SPDXCleaner(llm_client)
        cleaned_metadata, changes = cleaner.clean_metadata(
            metadata_list,
            change_callback=prompt_for_change if not silent else None,
        )

        # Display changes summary
        if changes["modified_count"] == 0:
            logger.info("No changes needed. All licenses are already in SPDX format.")

        logger.info(
            "Found %d license(s) cleaned (out of %d total rows)",
            changes["modified_count"],
            changes["total_rows"],
        )

        # Write output CSV using existing CSV writer
        logger.info("Writing cleaned CSV to: %s", output_csv)
        csv_writer = CSVReportingWritter()
        cleaned_csv = csv_writer.write(cleaned_metadata)
        write_file(str(output_path.absolute()), cleaned_csv)

        logger.info(
            "Successfully cleaned %d license(s) and wrote output to: %s",
            changes["modified_count"],
            output_csv,
        )

    except ValueError as e:
        logger.error("Configuration error: %s", e)
        sys.exit(1)
    except Exception as e:
        logger.error("Error during cleaning process: %s", e, exc_info=True)
        sys.exit(1)
